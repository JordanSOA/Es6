<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Classes</title>
  </head>
  <body>
    <script>
      /*
        Les classes ES6 offrent également la possibilité de définir des méthodes
        et propriétés dites statiques avec le mot-clé `static`. Les méthodes et
        propriétés statiques ont la particularité d'être indépendantes de toute
        instance et d'être directement accessibles depuis la classe.

        En ES5 elles équivalent à des méthodes définies directement sur la
        fonction constructeur (et non sur sa propriété `.prototype`).

        Exemple de classe :
          class Point {
            // Constructeur de la classe
            constructor(x, y) {
              this.x = x;
              this.y = y;
            }

            // Méthode statique
            static additionner(point1, point2) {
              return new Point(point1.x + point2.x, point1.y + point2.y);
            }
          }

          const A = new Point(1, 2);
          const B = new Point(3, 4);
          const C = Point.additionner(A, B); // appel d'une méthode statique de la classe Point
          C.x; // 4
          C.y; // 6

        Code équivalent en ES5 :
          "use strict";
          var Point = (function () {
            // Constructeur de la classe
            function Point(x, y) {
              this.x = x;
              this.y = y;
            }

            // Méthode statique
            Point.additionner = function (point1, point2) {
              return new Point(point1.x + point2.x, point1.y + point2.y);
            };

            return Point;
          }());

          var A = new Point(1, 2);
          var B = new Point(3, 4);
          var C = Point.additionner(A, B);
          C.x; // 4
          C.y; // 6
      */

      /*
        Reprenez le code de l'exercice précédent.

        1. Ajouter une méthode statique `intersection` à la classe Rectangle.
        Cette méthode prendra en argument 2 rectangles et renverra au choix :
        - un nouveau rectangle correspondant à l'intersection des deux rectangles
          fournis
        - `null` si les deux rectangles ne se chevauchent pas.

        Pour déterminer si deux rectangles se coupent il suffit de tester si :
          r1.droite > r2.gauche &&
          r1.gauche < r2.droite &&
          r1.bas > r2.haut &&
          r1.haut < r2.bas

        Pour déterminer les coordonnées du rectangle à l'intersection de r1 et
        r2 on pourra s'aider des formules :
          x = Math.max(r1.gauche, r2.gauche);
          y = Math.max(r1.haut, r2.haut);
          width = Math.min(r1.droite, r2.droite) - x;
          height = Math.min(r1.bas, r2.bas) - y;

        2. Créer 2 rectangles r1 et r2 avec les coordonnées de votre choix.
        Assurez-vous que r1 et r2 se chevauchent.

        3. Créez un troisièmme rectangle r3 qui sera le résultat de
        l'intersection des rectangles r1 et r2.

        4. Déplacer r1 et r2 de manière à ce qu'ils ne se chevauchent plus.
        Créez un rectangle r4 qui sera l'intersection des rectangles r1 et r2.
        Verifiez dans la console que r4 vaut bien `null`.
      */

      class Rectangle {
      constructor(x, y, h, w) {
        this.x = x;
        this.y = y;
        this.h = h;
        this.w = w;
      }

      deplaceA(déplacementX, déplacementY) {
        this.x = déplacementX;
        this.y = déplacementY;
      }

      redimensionner(a, b) {
        this.h = a;
        this.w = b;
      }

      get haut(){
        var bDroit = this.x + this.w;
        return " Côté Droit du Haut (x:"+bDroit+",y:"+this.y+")| Côté Gauche du Haut (x:"+this.x+",y:"+this.y+")";
      }

      get bas(){
        let bBas = this.y + this.h;
        return "Côté Droit du Bas (x:"+(this.x + this.w)+",y:"+bBas+")| Côté Gauche  du Bas (x:"+this.x+",y:"+bBas+")";
      }

      get gauche(){
        return  "Haut du bord Gauche (x:"+this.x+",y:"+this.y+")| Bas du Bord Gauche (x:"+this.x+",y"+(this.y + this.h)+")";
      }

      get droite(){
        return "Haut du bord Droit (x:"+(this.x + this.w)+",y:"+this.y+")| Bas du bord Droit (x:"+(this.x + this.w)+",y:"+(this.y + this.h)+")";
      }

      static intersection(rec1,rec2){
        if (rec1.droite > rec2.gauche && rec1.gauche < rec2.droite && rec1.bas > rec2.haut && rec1.haut < rec2.bas){
          x = Math.max(rec1.gauche, rec2.gauche);
          y = Math.max(rec1.haut, rec2.haut);
          w = Math.min(rec1.droite, rec2.droite) - x;
          h = Math.min(rec1.bas, rec2.bas) - y;
          var interRec = new Rectangle(x,y,w,h);
        } else {
          var interRec = new Rectangle(Math.max(rec1.gauche, rec2.gauche),Math.max(rec1.haut, rec2.haut),Math.min(rec1.droite, rec2.droite) - x,Math.min(rec1.bas, rec2.bas) - y);
          return null;
        }
      }
    };

    var r1 = new Rectangle(4, 4, 20, 60);
    var r2 = new Rectangle(10, 10, 15, 40);
    console.log(r1);
    console.log(r2);
    var r1Haut = r1.haut;
    var r1Bas = r1.bas;
    var r1Droite = r1.droite;
    var r1Gauche = r1.gauche;
    var r2Haut = r2.haut;
    var r2Bas = r2.bas;
    var r2Droite = r2.droite;
    var r2Gauche = r2.gauche;
    var r3 = Rectangle.intersection(r1,r2);
    console.log(r3);

    </script>
    <noscript>
      <p>VirtuoWorks® - tous droits réservés©</p>
    </noscript>
  </body>
</html>
